!function (e) { "function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof module && "object" == typeof module.exports ? module.exports = e(require("jquery")) : e(jQuery) }(function (y) { "use strict"; var b = y.keyboard = function (l, i) { var p, h = this; h.version = "1.30.3", h.$el = y(l), h.el = l, h.$el.data("keyboard", h), h.init = function () { h.initialized = !1, h.isTextArea = "textarea" === h.el.nodeName.toLowerCase(), h.isInput = "input" === h.el.nodeName.toLowerCase(), h.isContentEditable = !h.isTextArea && !h.isInput && h.el.isContentEditable; var e, t = b.css, a = b.events; if (h.isInput && y.inArray((h.el.type || "").toLowerCase(), b.supportedInputTypes) < 0) throw new TypeError('Input of type "' + h.el.type + '" is not supported; use type text, search, URL, tel or password'); h.settings = i || {}, i && i.position && (e = y.extend({}, i.position), i.position = null), h.options = p = y.extend(!0, {}, b.defaultOptions, i), e && (p.position = e, i.position = e), h.el.active = !0, h.namespace = ".keyboard" + Math.random().toString(16).slice(2), h.extensionNamespace = [], h.shiftActive = h.altActive = h.metaActive = h.sets = h.capsLock = !1, h.rows = ["", "-shift", "-alt", "-alt-shift"], h.inPlaceholder = h.$el.attr("placeholder") || "", h.watermark = b.watermark && "" !== h.inPlaceholder, h.repeatTime = 1e3 / (p.repeatRate || 20), p.preventDoubleEventTime = p.preventDoubleEventTime || 100, h.isOpen = !1, h.wheel = "function" == typeof y.fn.mousewheel, h.escapeRegex = /[-\/\\^$*+?.()|[\]{}]/g, n = b.keyCodes, h.alwaysAllowed = [n.capsLock, n.pageUp, n.pageDown, n.end, n.home, n.left, n.up, n.right, n.down, n.insert, n.delete], h.$keyboard = [], h.enabled = !0, h.checkCaret = p.lockInput || b.checkCaretSupport(), h.isContentEditable && (p.usePreview = !1), h.last = { start: 0, end: 0, key: "", val: "", preVal: "", layout: "", virtual: !0, keyset: [!1, !1, !1], wheel_$Keys: [], wheelIndex: 0, wheelLayers: [] }, h.temp = ["", 0, 0], y.each([a.kbInit, a.kbBeforeVisible, a.kbVisible, a.kbHidden, a.inputCanceled, a.inputAccepted, a.kbBeforeClose, a.inputRestricted], function (e, t) { "function" == typeof p[t] && h.$el.bind(t + h.namespace + "callbacks", p[t]) }), p.alwaysOpen && (p.stayOpen = !0), e = y(document), h.el.ownerDocument !== document && (e = e.add(h.el.ownerDocument)); var n = "keyup checkkeyboard mousedown touchstart "; p.closeByClickEvent && (n += "click "), e.bind(n.split(" ").join(h.namespace + " "), function (e) { clearTimeout(h.timer3), h.timer3 = setTimeout(function () { h.checkClose(e) }, 1) }), h.$el.addClass(t.input + " " + p.css.input).attr({ "aria-haspopup": "true", role: "textbox" }), (p.lockInput || h.el.readOnly) && (p.lockInput = !0, h.$el.addClass(t.locked).attr({ readonly: "readonly" })), h.isUnavailable() && h.$el.addClass(t.noKeyboard), p.openOn && h.bindFocus(), h.watermark || "" !== h.getValue(h.$el) || "" === h.inPlaceholder || "" === h.$el.attr("placeholder") || (h.$el.addClass(t.placeholder), h.setValue(h.inPlaceholder, h.$el)), h.$el.trigger(a.kbInit, [h, h.el]), p.alwaysOpen && h.reveal(), h.initialized = !0 }, h.toggle = function () { if (h.hasKeyboard()) { var e = h.$keyboard.find("." + b.css.keyToggle), t = !h.enabled; return h.preview.readonly = t || h.options.lockInput, h.$keyboard.toggleClass(b.css.keyDisabled, t).find("." + b.css.keyButton).not(e).attr("aria-disabled", t).each(function () { this.disabled = t }), e.toggleClass(b.css.keyDisabled, t), t && h.typing_options && (h.typing_options.text = ""), h } }, h.setCurrent = function () { var e = b.css, t = y("." + e.isCurrent), a = t.data("keyboard"); y.isEmptyObject(a) || a.el === h.el || a.close(!!a.options.autoAccept && "true"), t.removeClass(e.isCurrent), y("." + e.hasFocus).removeClass(e.hasFocus), h.$el.addClass(e.isCurrent), h.$preview.focus(), h.$keyboard.addClass(e.hasFocus), h.isCurrent(!0), h.isOpen = !0 }, h.isUnavailable = function () { return h.$el.is(":disabled") || !h.options.activeOnReadonly && h.$el.attr("readonly") && !h.$el.hasClass(b.css.locked) }, h.isCurrent = function (e) { var t = b.currentKeyboard || !1; return e ? t = b.currentKeyboard = h.el : !1 === e && t === h.el && (t = b.currentKeyboard = ""), t === h.el }, h.hasKeyboard = function () { return h.$keyboard && 0 < h.$keyboard.length }, h.isVisible = function () { return !!h.hasKeyboard() && h.$keyboard.is(":visible") }, h.setFocus = function () { var e = h.$preview || h.$el; p.noFocus || e.focus(), h.isContentEditable ? b.setEditableCaret(e, h.last.start, h.last.end) : b.caret(e, h.last) }, h.focusOn = function () { h && h.el.active && (h.isVisible() ? h.setCurrent() : (clearTimeout(h.timer), h.reveal())) }, h.redraw = function (e) { return e && (h.options.layout = e), h.$keyboard.length && (h.last.preVal = "" + h.last.val, h.saveLastChange(), h.setValue(h.last.val, h.$el), h.removeKeyboard(), h.shiftActive = h.altActive = h.metaActive = !1), h.isOpen = p.alwaysOpen, h.reveal(!0), h }, h.reveal = function (e) { var t = h.isOpen, a = b.css; if (h.opening = !t, y("." + a.keyboard).not("." + a.alwaysOpen).each(function () { var e = y(this).data("keyboard"); y.isEmptyObject(e) || e.close(!!e.options.autoAccept && "true") }), !h.isUnavailable()) return h.$el.removeClass(a.noKeyboard), p.openOn && h.$el.unbind(y.trim((p.openOn + " ").split(/\s+/).join(h.namespace + " "))), h.$keyboard && (!h.$keyboard || h.$keyboard.length && !y.contains(h.el.ownerDocument.body, h.$keyboard[0])) || h.startup(), h.watermark || h.getValue() !== h.inPlaceholder || (h.$el.removeClass(a.placeholder), h.setValue("", h.$el)), h.originalContent = h.isContentEditable ? h.$el.html() : h.getValue(h.$el), h.el === h.preview || h.isContentEditable || h.setValue(h.originalContent), p.acceptValid && p.checkValidOnInit && h.checkValid(), p.resetDefault && (h.shiftActive = h.altActive = h.metaActive = !1), h.showSet(), h.isVisible() || h.$el.trigger(b.events.kbBeforeVisible, [h, h.el]), (h.initialized || p.initialFocus || !p.initialFocus && h.$el.hasClass(b.css.initialFocus)) && h.setCurrent(), h.toggle(), h.$keyboard.show(), p.usePreview && b.msie && (void 0 === h.width && (h.$preview.hide(), h.width = Math.ceil(h.$keyboard.width()), h.$preview.show()), h.$preview.width(h.width)), h.reposition(), h.checkDecimal(), h.lineHeight = parseInt(h.$preview.css("lineHeight"), 10) || parseInt(h.$preview.css("font-size"), 10) + 4, p.caretToEnd && (a = h.isContentEditable ? b.getEditableLength(h.el) : h.originalContent.length, h.saveCaret(a, a)), b.allie && (0 === h.last.end && 0 < h.last.start && (h.last.end = h.last.start), h.last.start < 0 && (h.last.start = h.last.end = h.originalContent.length)), t || e ? (b.caret(h.$preview, h.last), h.opening = !1) : h.timer2 = setTimeout(function () { var e; h.opening = !1, /(number|email)/i.test(h.el.type) || p.caretToEnd || h.saveCaret(e, e, h.$el), (p.initialFocus || h.$el.hasClass(b.css.initialFocus)) && b.caret(h.$preview, h.last), h.last.eventTime = (new Date).getTime(), h.$el.trigger(b.events.kbVisible, [h, h.el]), h.timer = setTimeout(function () { h && h.saveCaret() }, 200) }, 10), h }, h.updateLanguage = function () { var e = b.layouts, t = p.language || e[p.layout] && e[p.layout].lang && e[p.layout].lang || [p.language || "en"], a = b.language, t = "[object Array]" === Object.prototype.toString.call(t) ? t[0] : t; t = (h.language = t).split("-")[0], p.display = y.extend(!0, {}, a.en.display, a[t] && a[t].display || {}, h.settings.display), p.combos = y.extend(!0, {}, a.en.combos, a[t] && a[t].combos || {}, h.settings.combos), p.wheelMessage = a[t] && a[t].wheelMessage || a.en.wheelMessage, p.rtl = e[p.layout] && e[p.layout].rtl || a[t] && a[t].rtl || !1, a[t] && a[t].comboRegex && (h.regex = a[t].comboRegex), h.decimal = /^\./.test(p.display.dec), h.$el.toggleClass("rtl", p.rtl).css("direction", p.rtl ? "rtl" : "") }, h.startup = function () { var e = b.css; (p.alwaysOpen || p.userClosed) && h.$preview || h.makePreview(), h.hasKeyboard() || ("custom" === p.layout && (p.layoutHash = "custom" + h.customHash()), h.layout = "custom" === p.layout ? p.layoutHash : p.layout, h.last.layout = h.layout, h.updateLanguage(), void 0 === b.builtLayouts[h.layout] && ("function" == typeof p.create ? h.$keyboard = p.create(h) : h.$keyboard.length || h.buildKeyboard(h.layout, !0)), h.$keyboard = b.builtLayouts[h.layout].$keyboard.clone(), h.$keyboard.data("keyboard", h), "" !== (h.el.id || "") && h.$keyboard.attr("id", h.el.id + b.css.idSuffix), h.makePreview()), h.$keyboard.attr("data-" + e.keyboard + "-layout", p.layout).attr("data-" + e.keyboard + "-language", h.language), h.$decBtn = h.$keyboard.find("." + e.keyPrefix + "dec"), (p.enterNavigation || h.isTextArea) && h.alwaysAllowed.push(b.keyCodes.enter), h.bindKeyboard(), h.$keyboard.appendTo(p.appendLocally ? h.$el.parent() : p.appendTo || "body"), h.bindKeys(), p.reposition && y.ui && y.ui.position && "body" === p.appendTo && y(window).bind("resize" + h.namespace, function () { h.reposition() }) }, h.reposition = function () { return h.position = !y.isEmptyObject(p.position) && p.position, y.ui && y.ui.position && h.position && (h.position.of = h.position.of || h.$el.data("keyboardPosition") || h.$el, h.position.collision = h.position.collision || "flipfit flipfit", h.position.at = p.usePreview ? p.position.at : p.position.at2, h.isVisible() && h.$keyboard.position(h.position)), h }, h.makePreview = function () { if (p.usePreview) { var e, t, a, n, i = b.css; for (h.$preview = h.$el.clone(!1).data("keyboard", h).removeClass(i.placeholder + " " + i.input).addClass(i.preview + " " + p.css.input).attr("tabindex", "-1").show(), h.preview = h.$preview[0], n = /^(data-|id|aria-haspopup)/i, e = (t = h.$preview.get(0).attributes).length - 1; 0 <= e; e--)a = t[e] && t[e].name, n.test(a) && h.preview.removeAttribute(a); y("<div />").addClass(i.wrapper).append(h.$preview).prependTo(h.$keyboard) } else h.$preview = h.$el, h.preview = h.el }, h.caret = function (e, t) { t = b.caret(h.$preview, e, t); return t instanceof y ? (h.saveCaret(t.start, t.end), h) : t }, h.saveCaret = function (e, t, a) { h.isCurrent() && (a = void 0 === e ? b.caret(a || h.$preview) : b.caret(a || h.$preview, e, t), h.last.start = void 0 === e ? a.start : e, h.last.end = void 0 === t ? a.end : t) }, h.saveLastChange = function (e) { h.last.val = e || h.getValue(h.$preview || h.$el), h.isContentEditable && (h.last.elms = h.el.cloneNode(!0)) }, h.setScroll = function () { var e, t, a, n; !h.isContentEditable && h.last.virtual && (n = h.last.val.substring(0, Math.max(h.last.start, h.last.end)), h.$previewCopy || (h.$previewCopy = h.$preview.clone().removeAttr("id").css({ position: "absolute", left: 0, zIndex: -10, visibility: "hidden" }).addClass(b.css.inputClone), h.$previewCopy[0].disabled = !0, h.isTextArea || h.$previewCopy.css({ "white-space": "pre", width: 0 }), p.usePreview ? h.$preview.after(h.$previewCopy) : h.$keyboard.prepend(h.$previewCopy)), h.isTextArea ? (h.$previewCopy.height(h.lineHeight).val(n), h.preview.scrollTop = h.lineHeight * (Math.floor(h.$previewCopy[0].scrollHeight / h.lineHeight) - 1)) : (h.$previewCopy.val(n.replace(/\s/g, " ")), t = /c/i.test(p.scrollAdjustment) ? h.preview.clientWidth / 2 : p.scrollAdjustment, e = h.$previewCopy[0].scrollWidth - 1, void 0 === h.last.scrollWidth && (h.last.scrollWidth = e, h.last.direction = !0), a = h.last.scrollWidth === e ? h.last.direction : h.last.scrollWidth < e, n = h.preview.clientWidth - t, a ? h.preview.scrollLeft = e < n ? 0 : e - n : e >= h.preview.scrollWidth - n ? h.preview.scrollLeft = h.preview.scrollWidth - t : h.preview.scrollLeft = 0 < e - t ? e - t : 0, h.last.scrollWidth = e, h.last.direction = a)) }, h.bindFocus = function () { p.openOn && h && h.el.active && (h.$el.bind(p.openOn + h.namespace, function () { h.focusOn() }), y(":focus")[0] === h.el && h.$el.blur()) }, h.bindKeyboard = function () { var s, o = b.keyCodes, r = b.builtLayouts[h.layout], e = h.namespace + "keybindings"; h.$preview.unbind(h.namespace).bind("click" + e + " touchstart" + e, function () { p.alwaysOpen && !h.isCurrent() && h.reveal(), h.timer2 = setTimeout(function () { h && h.saveCaret() }, 150) }).bind("keypress" + e, function (e) { if (p.lockInput) return !1; if (h.isCurrent()) { var t = e.charCode || e.which, a = t >= o.A && t <= o.Z, n = t >= o.a && t <= o.z, i = h.last.key = String.fromCharCode(t); if (!(t < o.space)) { if (h.last.virtual = !1, h.last.event = e, h.last.$key = [], h.checkCaret && h.saveCaret(), t !== o.capsLock && (a || n) && (h.capsLock = a && !e.shiftKey || n && e.shiftKey, h.capsLock && !h.shiftActive && (h.shiftActive = !0, h.showSet())), p.restrictInput) { if ((e.which === o.backSpace || 0 === e.which) && y.inArray(e.keyCode, h.alwaysAllowed)) return; -1 === y.inArray(i, r.acceptedKeys) && (e.preventDefault(), (s = y.extend({}, e)).type = b.events.inputRestricted, h.$el.trigger(s, [h, h.el])) } else if ((e.ctrlKey || e.metaKey) && (e.which === o.A || e.which === o.C || e.which === o.V || e.which >= o.X && e.which <= o.Z)) return; r.hasMappedKeys && r.mappedKeys.hasOwnProperty(i) && (h.last.key = r.mappedKeys[i], h.insertText(h.last.key), e.preventDefault()), "function" == typeof p.beforeInsert && (h.insertText(h.last.key), e.preventDefault()), h.checkMaxLength() } } }).bind("keyup" + e, function (e) { if (h.isCurrent()) { switch (h.last.virtual = !1, e.which) { case o.tab: if (h.tab && !p.lockInput) { h.shiftActive = e.shiftKey; var t = b.keyaction.tab(h); if (h.tab = !1, !t) return !1 } else e.preventDefault(); break; case o.escape: return p.ignoreEsc || h.close(!(!p.autoAccept || !p.autoAcceptOnEsc) && "true"), !1 }clearTimeout(h.throttled), h.throttled = setTimeout(function () { h && h.isVisible() && h.checkCombos() }, 100), h.checkMaxLength(), h.last.preVal = "" + h.last.val, h.saveLastChange(); var a = y.Event(b.events.kbChange); if (a.action = h.last.key, h.$el.trigger(a, [h, h.el]), "function" == typeof p.change) return a.type = b.events.inputChange, p.change(a, h, h.el), !1; p.acceptValid && p.autoAcceptOnValid && "function" == typeof p.validate && p.validate(h, h.getValue(h.$preview)) && (h.$preview.blur(), h.accept()) } }).bind("keydown" + e, function (e) { if (h.last.keyPress = e.which, p.alwaysOpen && !h.isCurrent() && h.reveal(), e.which === o.tab) return !(h.tab = !0); if (p.lockInput || e.timeStamp === h.last.timeStamp) return !p.lockInput; switch (h.last.timeStamp = e.timeStamp, h.last.virtual = !1, e.which) { case o.backSpace: b.keyaction.bksp(h, null, e), e.preventDefault(); break; case o.enter: b.keyaction.enter(h, null, e); break; case o.capsLock: h.shiftActive = h.capsLock = !h.capsLock, h.showSet(); break; case o.V: if (e.ctrlKey || e.metaKey) { if (p.preventPaste) return void e.preventDefault(); h.checkCombos() } } }).bind("mouseup touchend ".split(" ").join(e + " "), function () { h.last.virtual = !0, h.saveCaret() }), h.$keyboard.bind("mousedown click touchstart ".split(" ").join(h.namespace + " "), function (e) { e.stopPropagation(), h.isCurrent() || (h.reveal(), y(h.el.ownerDocument).trigger("checkkeyboard" + h.namespace)), h.setFocus() }), p.preventPaste && (h.$preview.bind("contextmenu" + h.namespace, function (e) { e.preventDefault() }), h.$el.bind("contextmenu" + h.namespace, function (e) { e.preventDefault() })) }, h.bindButton = function (e, t) { function a(e) { e.stopPropagation(), e.$target = y(this).closest("." + b.css.keyboard + ", ." + b.css.input), t.call(this, e) } var n = "." + b.css.keyButton; return y.fn.on ? h.$keyboard.on(e, n, a) : y.fn.delegate && h.$keyboard.delegate(n, e, a), h }, h.unbindButton = function (e) { return y.fn.off ? h.$keyboard.off(e) : y.fn.undelegate && h.$keyboard.undelegate("." + b.css.keyButton, e), h }, h.bindKeys = function () { var s = b.css; h.unbindButton(h.namespace + " " + h.namespace + "kb").bindButton("mouseenter mouseleave touchstart ".split(" ").join(h.namespace + " "), function (e) { var a, t, n, i; !p.alwaysOpen && !p.userClosed || "mouseleave" === e.type || h.isCurrent() || (h.reveal(), h.setFocus()), h.isCurrent() && !this.disabled && (t = h.last, n = y(this), i = e.type, p.useWheel && h.wheel && (e = h.getLayers(n), a = (e.length ? e.map(function () { return y(this).attr("data-value") || "" }).get() : "") || [n.text()], t.wheel_$Keys = e, t.wheelLayers = a, t.wheelIndex = y.inArray(n.attr("data-value"), a)), "mouseenter" !== i && "touchstart" !== i || "password" === h.el.type || n.hasClass(p.css.buttonDisabled) || (n.addClass(p.css.buttonHover), p.useWheel && h.wheel && n.attr("title", function (e, t) { return h.wheel && "" === t && h.sets && 1 < a.length && "touchstart" !== i ? p.wheelMessage : t })), "mouseleave" === i && (n.removeClass("password" === h.el.type ? "" : p.css.buttonHover), p.useWheel && h.wheel && (t.wheelIndex = 0, t.wheelLayers = [], t.wheel_$Keys = [], n.attr("title", function (e, t) { return t === p.wheelMessage ? "" : t }).html(n.attr("data-html"))))) }).bindButton(p.keyBinding.split(" ").join(h.namespace + " ") + h.namespace + " " + b.events.kbRepeater, function (e) { if (e.preventDefault(), !h.$keyboard.is(":visible") || this.disabled) return !1; var t, a = h.last, n = y(this), i = (new Date).getTime(); if (p.useWheel && h.wheel && (n = a.wheel_$Keys.length && -1 < a.wheelIndex ? a.wheel_$Keys.eq(a.wheelIndex) : n), t = n.attr("data-action"), !(i - (a.eventTime || 0) < p.preventDoubleEventTime)) { if (a.eventTime = i, a.event = e, a.virtual = !0, a.$key = n, a.key = n.attr("data-value"), a.keyPress = "", h.setFocus(), /^meta/.test(t) && (t = "meta"), t === a.key && "string" == typeof b.keyaction[t]) a.key = t = b.keyaction[t]; else if (t in b.keyaction && "function" == typeof b.keyaction[t]) { if (!1 === b.keyaction[t](h, this, e)) return !1; t = null } return h.hasKeyboard() ? (null != t && (a.key = y(this).hasClass(s.keyAction) ? t : a.key, h.insertText(a.key), h.capsLock || p.stickyShift || e.shiftKey || (h.shiftActive = !1, h.showSet(n.attr("data-name")))), b.caret(h.$preview, a), h.checkCombos(), (e = y.extend({}, e, y.Event(b.events.kbChange))).target = h.el, e.action = a.key, h.$el.trigger(e, [h, h.el]), a.preVal = "" + a.val, h.saveLastChange(), "function" == typeof p.change ? (e.type = b.events.inputChange, p.change(e, h, h.el), !1) : void 0) : !1 } }).bindButton("mouseup" + h.namespace + " " + "mouseleave touchend touchmove touchcancel ".split(" ").join(h.namespace + "kb "), function (e) { h.last.virtual = !0; var t, a = y(this); if ("touchmove" === e.type) { if ((t = a.offset()).right = t.left + a.outerWidth(), t.bottom = t.top + a.outerHeight(), e.originalEvent.touches[0].pageX >= t.left && e.originalEvent.touches[0].pageX < t.right && e.originalEvent.touches[0].pageY >= t.top && e.originalEvent.touches[0].pageY < t.bottom) return !0 } else /(mouseleave|touchend|touchcancel)/i.test(e.type) ? a.removeClass(p.css.buttonHover) : (!p.noFocus && h.isCurrent() && h.isVisible() && h.$preview.focus(), h.checkCaret && b.caret(h.$preview, h.last)); return h.mouseRepeat = [!1, ""], clearTimeout(h.repeater), p.acceptValid && p.autoAcceptOnValid && "function" == typeof p.validate && p.validate(h, h.getValue()) && (h.$preview.blur(), h.accept()), !1 }).bindButton("click" + h.namespace, function () { return !1 }).bindButton("mousewheel" + h.namespace, h.throttleEvent(function (e, t) { var a = y(this); if (a && !a.hasClass(s.keyAction) && h.last.wheel_$Keys[0] === this && p.useWheel && h.wheel) { t = t || e.deltaY; var n, e = h.last.wheelLayers || []; return 1 < e.length ? (n = h.last.wheelIndex + (0 < t ? -1 : 1), e.length - 1 < n && (n = 0), n < 0 && (n = e.length - 1)) : n = 0, h.last.wheelIndex = n, a.html(e[n]), !1 } }, 30)).bindButton("mousedown touchstart ".split(" ").join(h.namespace + "kb "), function () { var e = y(this); if (e && (!e.hasClass(s.keyAction) || e.is("." + s.keyPrefix + "tab bksp space enter".split(" ").join(",." + s.keyPrefix)))) return 0 !== p.repeatRate && (h.mouseRepeat = [!0, e], setTimeout(function () { h && h.mouseRepeat[0] && h.mouseRepeat[1] === e && !e[0].disabled && h.repeatKey(e) }, p.repeatDelay)), !1 }) }, h.throttleEvent = function (e, t) { var a; return function () { a || (e.apply(this, arguments), a = !0, setTimeout(function () { a = !1 }, t)) } }, h.execCommand = function (e, t) { h.el.ownerDocument.execCommand(e, !1, t), h.el.normalize(), p.reposition && h.reposition() }, h.getValue = function (e) { return (e = e || h.$preview)[h.isContentEditable ? "text" : "val"]() }, h.setValue = function (e, t) { return t = t || h.$preview, h.isContentEditable ? e !== t.text() && (b.replaceContent(t, e), h.saveCaret()) : t.val(e), h }, h.insertText = function (e) { if (!h.$preview) return h; if ("function" == typeof p.beforeInsert && (e = p.beforeInsert(h.last.event, h, h.el, e)), void 0 === e || !1 === e) return h.last.key = "", h; if (h.isContentEditable) return h.insertContentEditable(e); var t = !1, a = "\b" === e, n = h.getValue(), i = b.caret(h.$preview), s = n.length; return i.end < i.start && (i.end = i.start), i.start > s && (i.end = i.start = s), h.isTextArea && b.msie && "\n" === n.substring(i.start, i.start + 1) && (i.start += 1, i.end += 1), s = i.start, "{d}" === e && (e = "", i.end += 1), a && (e = "", t = a && s === i.end && 0 < s), n = n.substring(0, s - (t ? 1 : 0)) + e + n.substring(i.end), s += t ? -1 : e.length, h.setValue(n), h.saveCaret(s, s), h.setScroll(), h }, h.insertContentEditable = function (e) { return h.$preview.focus(), h.execCommand("insertText", e), h.saveCaret(), h }, h.checkMaxLength = function () { if (h.$preview) { var e, t = h.getValue(), a = h.isContentEditable ? b.getEditableLength(h.el) : t.length; return !1 !== p.maxLength && a > p.maxLength && (e = b.caret(h.$preview).start, a = Math.min(e, p.maxLength), p.maxInsert || (t = h.last.val, a = e - 1), h.setValue(t.substring(0, p.maxLength)), h.saveCaret(a, a)), h.$decBtn.length && h.checkDecimal(), h } }, h.repeatKey = function (e) { e.trigger(b.events.kbRepeater), h.mouseRepeat[0] && (h.repeater = setTimeout(function () { h && h.repeatKey(e) }, h.repeatTime)) }, h.getKeySet = function () { var e = []; return h.altActive && e.push("alt"), h.shiftActive && e.push("shift"), h.metaActive && e.push(h.metaActive), e.length ? e.join("+") : "normal" }, h.showKeySet = function (e) { return "string" == typeof e ? (h.last.keyset = [h.shiftActive, h.altActive, h.metaActive], h.shiftActive = /shift/i.test(e), h.altActive = /alt/i.test(e), /\bmeta/.test(e) ? (h.metaActive = !0, h.showSet(e.match(/\bmeta[\w-]+/i)[0])) : (h.metaActive = !1, h.showSet())) : h.showSet(e), h }, h.showSet = function (e) { if (h.hasKeyboard()) { p = h.options; var t = b.css, a = "." + t.keyPrefix, n = p.css.buttonActive, i = "", s = (h.shiftActive ? 1 : 0) + (h.altActive ? 2 : 0); if (h.shiftActive || (h.capsLock = !1), h.metaActive ? (h.shiftActive && (e = (e || "").replace("-shift", "")), h.altActive && (e = (e || "").replace("-alt", "")), "" === (i = /^meta/i.test(e) ? e : "") ? i = !0 === h.metaActive ? "" : h.metaActive : h.metaActive = i, (!p.stickyShift && h.last.keyset[2] !== h.metaActive || (h.shiftActive || h.altActive) && !h.$keyboard.find("." + t.keySet + "-" + i + h.rows[s]).length) && (h.shiftActive = h.altActive = !1)) : !p.stickyShift && h.last.keyset[2] !== h.metaActive && h.shiftActive && (h.shiftActive = h.altActive = !1), i = 0 !== (s = (h.shiftActive ? 1 : 0) + (h.altActive ? 2 : 0)) || h.metaActive ? "" === i ? "" : "-" + i : "-normal", !h.$keyboard.find("." + t.keySet + i + h.rows[s]).length) return h.shiftActive = h.last.keyset[0], h.altActive = h.last.keyset[1], void (h.metaActive = h.last.keyset[2]); h.$keyboard.find(a + "alt," + a + "shift,." + t.keyAction + "[class*=meta]").removeClass(n).end().find(a + "alt").toggleClass(n, h.altActive).end().find(a + "shift").toggleClass(n, h.shiftActive).end().find(a + "lock").toggleClass(n, h.capsLock).end().find("." + t.keySet).hide().end().find("." + (t.keyAction + a + i).replace("--", "-")).addClass(n), h.$keyboard.find("." + t.keySet + i + h.rows[s])[0].style.display = "inline-block", h.metaActive && h.$keyboard.find(a + h.metaActive).toggleClass(n, !1 !== h.metaActive), h.last.keyset = [h.shiftActive, h.altActive, h.metaActive], h.$el.trigger(b.events.kbKeysetChange, [h, h.el]), p.reposition && h.reposition() } }, h.checkCombos = function () { if (!(h.isVisible() || h.hasKeyboard() && h.$keyboard.hasClass(b.css.hasFocus))) return h.getValue(h.$preview || h.$el); var e, t, a, n = h.getValue(), i = b.caret(h.$preview), s = b.builtLayouts[h.layout], o = h.isContentEditable ? b.getEditableLength(h.el) : n.length, r = o; return "" === n || (i.end < i.start && (i.end = i.start), i.start > r && (i.end = i.start = r), b.msie && "\n" === n.substring(i.start, i.start + 1) && (i.start += 1, i.end += 1), p.useCombos && (b.msie ? n = n.replace(h.regex, function (e, t, a) { return p.combos.hasOwnProperty(t) && p.combos[t][a] || e }) : h.$preview.length && (e = i.start - (0 <= i.start - 2 ? 2 : 0), b.caret(h.$preview, e, i.end), t = (a = function (e) { return (e || "").replace(h.regex, function (e, t, a) { return p.combos.hasOwnProperty(t) && p.combos[t][a] || e }) })((e = b.caret(h.$preview)).text), e && e.replaceStr && t !== e.text && (h.isContentEditable ? b.replaceContent(l, a) : h.setValue(e.replaceStr(t))), n = h.getValue())), p.restrictInput && "" !== n && (e = s.acceptedKeys.length, (e = s.acceptedKeysRegex) || (t = y.map(s.acceptedKeys, function (e) { return e.replace(h.escapeRegex, "\\$&") }), -1 < h.alwaysAllowed.indexOf(b.keyCodes.enter) && t.push("\\n"), e = s.acceptedKeysRegex = new RegExp("(" + t.join("|") + ")", "g")), (t = n.match(e)) ? n = t.join("") : (n = "", r = 0)), i.start += o - r, i.end += o - r, h.setValue(n), h.saveCaret(i.start, i.end), h.setScroll(), h.checkMaxLength()), p.acceptValid && h.checkValid(), n }, h.checkValid = function () { var e = b.css, t = h.$keyboard.find("." + e.keyPrefix + "accept"), a = !0; "function" == typeof p.validate && (a = p.validate(h, h.getValue(), !1)), t.toggleClass(e.inputInvalid, !a).toggleClass(e.inputValid, a).attr("title", t.attr("data-title") + " (" + p.display[a ? "valid" : "invalid"] + ")") }, h.checkDecimal = function () { h.decimal && /\./g.test(h.preview.value) || !h.decimal && /\,/g.test(h.preview.value) ? h.$decBtn.attr({ disabled: "disabled", "aria-disabled": "true" }).removeClass(p.css.buttonHover).addClass(p.css.buttonDisabled) : h.$decBtn.removeAttr("disabled").attr({ "aria-disabled": "false" }).addClass(p.css.buttonDefault).removeClass(p.css.buttonDisabled) }, h.getLayers = function (e) { var t = b.css, a = e.attr("data-pos"); return e.closest("." + t.keyboard).find('button[data-pos="' + a + '"]').filter(function () { return "" !== y(this).find("." + t.keyText).text() }).add(e) }, h.switchInput = function (e, t) { if ("function" == typeof p.switchInput) p.switchInput(h, e, t); else { h.$keyboard.length && h.$keyboard.hide(); var a = !1, n = y("button, input, select, textarea, a, [contenteditable]").filter(":visible").not(":disabled"), e = n.index(h.$el) + (e ? 1 : -1); if (h.$keyboard.length && h.$keyboard.show(), e > n.length - 1 && (a = p.stopAtEnd, e = 0), e < 0 && (a = p.stopAtEnd, e = n.length - 1), !a) { if (!(t = h.close(t))) return; (t = n.eq(e).data("keyboard")) && t.options.openOn.length ? t.focusOn() : n.eq(e).focus() } } return !1 }, h.close = function (e) { if (h.isOpen && h.$keyboard.length) { clearTimeout(h.throttled); var t = b.css, a = b.events, n = e ? h.checkCombos() : h.originalContent; if (e && "function" == typeof p.validate && !p.validate(h, n, !0) && (n = h.originalContent, e = !1, p.cancelClose)) return; h.isCurrent(!1), h.isOpen = p.alwaysOpen || p.userClosed, h.isContentEditable && !e ? h.$el.html(n) : h.setValue(n, h.$el), h.$el.removeClass(t.isCurrent + " " + t.inputAutoAccepted).addClass(!e || !0 === e ? "" : t.inputAutoAccepted).trigger(a.inputChange), p.alwaysOpen || h.$el.trigger(a.kbBeforeClose, [h, h.el, e || !1]), b.caret(h.$preview, h.last), h.$el.trigger(e ? a.inputAccepted : a.inputCanceled, [h, h.el]).trigger(p.alwaysOpen ? a.kbInactive : a.kbHidden, [h, h.el]).blur(), h && (h.last.eventTime = (new Date).getTime(), p.alwaysOpen || p.userClosed && "true" === e || !h.$keyboard.length || (h.removeKeyboard(), h.timer = setTimeout(function () { h && h.bindFocus() }, 200)), h.watermark || "" !== h.el.value || "" === h.inPlaceholder || (h.$el.addClass(t.placeholder), h.setValue(h.inPlaceholder, h.$el))) } return !!e }, h.accept = function () { return h.close(!0) }, h.checkClose = function (e) { var t, a, n; h.opening || (t = y.keyboard.css, (a = e.$target || y(e.target).closest("." + b.css.keyboard + ", ." + b.css.input)).length || (a = y(e.target)), a.length && a.hasClass(t.keyboard) ? (n = a.data("keyboard")) !== h && !n.$el.hasClass(t.isCurrent) && n.options.openOn && e.type === p.openOn && n.focusOn() : h.escClose(e, a)) }, h.escCloseCallback = { keepOpen: function () { return !h.isOpen } }, h.escClose = function (e, t) { if (h.isOpen) { if (e && "keyup" === e.type) return e.which !== b.keyCodes.escape || p.ignoreEsc ? "" : h.close(!(!p.autoAccept || !p.autoAcceptOnEsc) && "true"); var a, n = !1, i = t.length && t || y(e.target); y.each(h.escCloseCallback, function (e, t) { "function" == typeof t && (n = n || t(i)) }), n || (!h.isCurrent() && h.isOpen || h.isOpen && i[0] !== h.el) && ((p.stayOpen || p.userClosed) && !i.hasClass(b.css.input) || (b.allie && e.preventDefault(), p.closeByClickEvent && "input" !== (a = i[0] && i[0].nodeName.toLowerCase()) && "textarea" !== a && "click" !== e.type || h.close(!!p.autoAccept && "true"))) } }, h.keyBtn = y("<button />").attr({ role: "button", type: "button", "aria-disabled": "false", tabindex: "-1" }).addClass(b.css.keyButton), h.processName = function (e) { var t, a, n = (e || "").replace(/[^a-z0-9-_]/gi, ""), i = n.length, s = []; if (1 < i && e === n) return e; if (i = e.length) { for (t = 0; t < i; t++)a = e[t], s.push(/[a-z0-9-_]/i.test(a) ? /[-_]/.test(a) && 0 !== t ? "" : a : (0 === t ? "" : "-") + a.charCodeAt(0)); return s.join("") } return e }, h.processKeys = function (e) { var t, a = e.indexOf("</"), n = { name: e, map: "", title: "" }; return -1 < a || (a = e.split(/:(?!\/\/)/), /\(.+\)/.test(a[0]) || /^:\(.+\)/.test(e) || /\([(:)]\)/.test(e) ? /\([(:)]\)/.test(e) ? (t = a[0].match(/([^(]+)\((.+)\)/)) && t.length ? (n.name = t[1], n.map = t[2], n.title = 1 < a.length ? a.slice(1).join(":") : "") : (n.name = e.match(/([^(]+)/)[0], ":" === n.name && (a = a.slice(1)), null === t && (n.map = ":", a = a.slice(2)), n.title = a.length ? a.join(":") : "") : (n.map = e.match(/\(([^()]+?)\)/)[1], "" === (t = (e = e.replace(/\(([^()]+)\)/, "")).split(":"))[0] ? (n.name = ":", a = a.slice(1)) : n.name = t[0], n.title = 1 < a.length ? a.slice(1).join(":") : "") : ("" !== e && "" === a[0] ? (n.name = ":", a = a.slice(1)) : n.name = a[0], n.title = 1 < a.length ? a.slice(1).join(":") : ""), n.title = y.trim(n.title).replace(/_/g, " ")), n }, h.addKey = function (e, t, a) { var n, i = {}, s = h.processKeys(a ? e : t), t = b.css; return !a && p.display[s.name] ? (n = h.processKeys(p.display[s.name])).action = h.processKeys(e).name : (n = s).action = s.name, i.name = h.processName(s.name), "" !== n.name && ("" !== n.map ? (b.builtLayouts[h.layout].mappedKeys[n.map] = n.name, b.builtLayouts[h.layout].acceptedKeys.push(n.name)) : a && b.builtLayouts[h.layout].acceptedKeys.push(n.name)), e = a ? "" === i.name ? "" : t.keyPrefix + i.name : t.keyAction + " " + t.keyPrefix + n.action, e += (2 < n.name.length ? " " + t.keyWide : "") + " " + p.css.buttonDefault, i.html = '<span class="' + t.keyText + '">' + n.name + "</span>", i.$key = h.keyBtn.clone().attr({ "data-value": a ? n.name : n.action, "data-name": n.action, "data-pos": h.temp[1] + "," + h.temp[2], "data-action": n.action, "data-html": i.html }).addClass(e).html(i.html).appendTo(h.temp[0]), n.map && i.$key.attr("data-mapped", n.map), (n.title || s.title) && i.$key.attr({ "data-title": s.title || n.title, title: s.title || n.title }), "function" == typeof p.buildKey && (n = (i = p.buildKey(h, i)).$key.html(), i.$key.attr("data-html", n)), i.$key }, h.customHash = function (e) { var t, a, n, i, s = [], o = []; for (a in e = void 0 === e ? p.customLayout : e) e.hasOwnProperty(a) && s.push(e[a]); if ((n = 0) === (i = (o = o.concat.apply(o, s).join(" ")).length)) return n; for (t = 0; t < i; t++)n = (n << 5) - n + o.charCodeAt(t), n &= n; return n }, h.buildKeyboard = function (e, t) { y.isEmptyObject(p.display) && h.updateLanguage(); var a, n, i, s = b.css, o = 0, r = b.builtLayouts[e || h.layout || p.layout] = { mappedKeys: {}, acceptedKeys: [] }, l = r.acceptedKeys = p.restrictInclude && ("" + p.restrictInclude).split(/\s+/) || [], c = s.keyboard + " " + p.css.popup + " " + p.css.container + (p.alwaysOpen || p.userClosed ? " " + s.alwaysOpen : ""), d = y("<div />").addClass(c).attr({ role: "textbox" }).hide(), u = y.inArray("{space}", l); return -1 < u && (l[u] = " "), c = t && "custom" === p.layout || !b.layouts.hasOwnProperty(p.layout) ? (p.layout = "custom", b.layouts.custom = p.customLayout || { normal: ["{cancel}"] }) : b.layouts[!t && (e || h.layout) || p.layout], y.each(c, function (e, t) { if ("" !== e && !/^(name|lang|rtl)$/i.test(e)) for ("default" === e && (e = "normal"), o++, n = y("<div />").attr("name", e).addClass(s.keySet + " " + s.keySet + "-" + e).appendTo(d).toggle("normal" === e), a = 0; a < t.length; a++)i = y.trim(t[a]).replace(/\{(\.?)[\s+]?:[\s+]?(\.?)\}/g, "{$1:$2}"), h.buildRow(n, a, i.split(/\s+/), l), n.find("." + s.keyButton + ",." + s.keySpacer).filter(":last").after('<br class="' + s.endRow + '"/>') }), 1 < o && (h.sets = !0), r.hasMappedKeys = !y.isEmptyObject(r.mappedKeys), r.$keyboard = d }, h.buildRow = function (e, t, a, n) { for (var i, s, o, r, l, c = b.css, d = 0; d < a.length; d++)if (o = !(h.temp = [e, t, d]), 0 !== a[d].length) if (/^\{\S+\}$/.test(a[d])) if (r = a[d].match(/^\{(\S+)\}$/)[1], /\!\!/.test(r) && (r = r.replace("!!", ""), o = !0), /^sp:((\d+)?([\.|,]\d+)?)(em|px)?$/i.test(r) && (l = parseFloat(r.replace(/,/, ".").match(/^sp:((\d+)?([\.|,]\d+)?)(em|px)?$/i)[1] || 0), y('<span class="' + c.keyText + '"></span>').width(r.match(/px/i) ? l + "px" : 2 * l + "em").addClass(c.keySpacer).appendTo(e)), /^empty(:((\d+)?([\.|,]\d+)?)(em|px)?)?$/i.test(r)) l = /:/.test(r) ? parseFloat(r.replace(/,/, ".").match(/^empty:((\d+)?([\.|,]\d+)?)(em|px)?$/i)[1] || 0) : "", h.addKey("", " ", !0).addClass(p.css.buttonDisabled + " " + p.css.buttonEmpty).attr("aria-disabled", !0).width(l ? r.match("px") ? l + "px" : 2 * l + "em" : ""); else if (/^meta[\w-]+\:?(\w+)?/i.test(r)) h.addKey(r.split(":")[0], r).addClass(c.keyHasActive); else switch ((s = r.split(":"))[0].toLowerCase()) { case "a": case "accept": h.addKey("accept", r).addClass(p.css.buttonAction + " " + c.keyAction); break; case "alt": case "altgr": h.addKey("alt", r).addClass(c.keyHasActive); break; case "b": case "bksp": h.addKey("bksp", r); break; case "c": case "cancel": h.addKey("cancel", r).addClass(p.css.buttonAction + " " + c.keyAction); break; case "combo": h.addKey("combo", r).addClass(c.keyHasActive).attr("title", function (e, t) { return t + " " + p.display[p.useCombos ? "active" : "disabled"] }).toggleClass(p.css.buttonActive, p.useCombos); break; case "dec": n.push(h.decimal ? "." : ","), h.addKey("dec", r); break; case "e": case "enter": h.addKey("enter", r).addClass(p.css.buttonAction + " " + c.keyAction); break; case "lock": h.addKey("lock", r).addClass(c.keyHasActive); break; case "s": case "shift": h.addKey("shift", r).addClass(c.keyHasActive); break; case "sign": n.push("-"), h.addKey("sign", r); break; case "space": n.push(" "), h.addKey("space", r); break; case "t": case "tab": h.addKey("tab", r); break; default: b.keyaction.hasOwnProperty(s[0]) && h.addKey(s[0], r).toggleClass(p.css.buttonAction + " " + c.keyAction, o) } else i = a[d], h.addKey(i, i, !0) }, h.removeBindings = function (e) { y(document).unbind(e), h.el.ownerDocument !== document && y(h.el.ownerDocument).unbind(e), y(window).unbind(e), h.$el.unbind(e) }, h.removeKeyboard = function () { h.$decBtn = [], p.usePreview && h.$preview.removeData("keyboard"), h.$preview.unbind(h.namespace + "keybindings"), h.preview = null, h.$preview = null, h.$previewCopy = null, h.$keyboard.removeData("keyboard"), h.$keyboard.remove(), h.$keyboard = [], h.isOpen = !1, h.isCurrent(!1) }, h.destroy = function (e) { var t, a = b.css, n = h.extensionNamespace.length, a = [a.input, a.locked, a.placeholder, a.noKeyboard, a.alwaysOpen, p.css.input, a.isCurrent].join(" "); for (clearTimeout(h.timer), clearTimeout(h.timer2), clearTimeout(h.timer3), h.$keyboard.length && h.removeKeyboard(), h.options.openOn && h.removeBindings(h.options.openOn), h.removeBindings(h.namespace), h.removeBindings(h.namespace + "callbacks"), t = 0; t < n; t++)h.removeBindings(h.extensionNamespace[t]); h.el.active = !1, h.$el.removeClass(a).removeAttr("aria-haspopup").removeAttr("role").removeData("keyboard"), h = null, "function" == typeof e && e() }, h.init() }; return b.keyCodes = { backSpace: 8, tab: 9, enter: 13, capsLock: 20, escape: 27, space: 32, pageUp: 33, pageDown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40, insert: 45, delete: 46, A: 65, Z: 90, V: 86, C: 67, X: 88, a: 97, z: 122 }, b.css = { idSuffix: "_keyboard", initialFocus: "keyboard-init-focus", input: "ui-keyboard-input", inputClone: "ui-keyboard-preview-clone", wrapper: "ui-keyboard-preview-wrapper", preview: "ui-keyboard-preview", keyboard: "ui-keyboard", keySet: "ui-keyboard-keyset", keyButton: "ui-keyboard-button", keyWide: "ui-keyboard-widekey", keyPrefix: "ui-keyboard-", keyText: "ui-keyboard-text", keyHasActive: "ui-keyboard-hasactivestate", keyAction: "ui-keyboard-actionkey", keySpacer: "ui-keyboard-spacer", keyToggle: "ui-keyboard-toggle", keyDisabled: "ui-keyboard-disabled", divWrapperCE: "ui-keyboard-div-wrapper", locked: "ui-keyboard-lockedinput", alwaysOpen: "ui-keyboard-always-open", noKeyboard: "ui-keyboard-nokeyboard", placeholder: "ui-keyboard-placeholder", hasFocus: "ui-keyboard-has-focus", isCurrent: "ui-keyboard-input-current", inputValid: "ui-keyboard-valid-input", inputInvalid: "ui-keyboard-invalid-input", inputAutoAccepted: "ui-keyboard-autoaccepted", endRow: "ui-keyboard-button-endrow" }, b.events = { kbChange: "keyboardChange", kbBeforeClose: "beforeClose", kbBeforeVisible: "beforeVisible", kbVisible: "visible", kbInit: "initialized", kbInactive: "inactive", kbHidden: "hidden", kbRepeater: "repeater", kbKeysetChange: "keysetChange", inputAccepted: "accepted", inputCanceled: "canceled", inputChange: "change", inputRestricted: "restricted" }, b.keyaction = { accept: function (e) { return e.close(!0), !1 }, alt: function (e) { e.altActive = !e.altActive, e.showSet() }, bksp: function (e) { e.isContentEditable ? (e.execCommand("delete"), e.saveCaret()) : e.insertText("\b") }, cancel: function (e) { return e.close(), !1 }, clear: function (e) { e.$preview[e.isContentEditable ? "text" : "val"](""), e.$decBtn.length && e.checkDecimal() }, combo: function (e) { var t = e.options, a = !t.useCombos, n = e.$keyboard.find("." + b.css.keyPrefix + "combo"); return t.useCombos = a, n.toggleClass(t.css.buttonActive, a).attr("title", n.attr("data-title") + " (" + t.display[a ? "active" : "disabled"] + ")"), a && e.checkCombos(), !1 }, dec: function (e) { e.insertText(e.decimal ? "." : ",") }, del: function (e) { e.isContentEditable ? e.execCommand("forwardDelete") : e.insertText("{d}") }, default: function (e) { e.shiftActive = e.altActive = e.metaActive = !1, e.showSet() }, enter: function (e, t, a) { var n = e.options; return a.shiftKey ? n.enterNavigation ? e.switchInput(!a[n.enterMod], !0) : e.close(!0) : !n.enterNavigation || e.isTextArea && !a[n.enterMod] ? (e.isTextArea && y(a.target).closest("button").length && e.insertText((b.msie ? " " : "") + "\n"), void (e.isContentEditable && !n.enterNavigation && (e.execCommand("insertHTML", '<div><br class="' + b.css.divWrapperCE + '"></div>'), setTimeout(function () { b.keyaction.right(e), e.saveCaret() }, 0)))) : e.switchInput(!a[n.enterMod], !!n.autoAccept && "true") }, lock: function (e) { e.last.keyset[0] = e.shiftActive = e.capsLock = !e.capsLock, e.showSet() }, left: function (e) { var t = b.caret(e.$preview); 0 <= t.start - 1 && (e.last.start = e.last.end = t.start - 1, b.caret(e.$preview, e.last), e.setScroll()) }, meta: function (e, t) { t = y(t); e.metaActive = !t.hasClass(e.options.css.buttonActive), e.showSet(t.attr("data-name")) }, next: function (e) { return e.switchInput(!0, e.options.autoAccept), !1 }, normal: function (e) { e.shiftActive = e.altActive = e.metaActive = !1, e.showSet() }, prev: function (e) { return e.switchInput(!1, e.options.autoAccept), !1 }, right: function (e) { var t = b.caret(e.$preview), a = e.isContentEditable ? b.getEditableLength(e.el) : e.getValue().length; t.end + 1 <= a && (e.last.start = e.last.end = t.end + 1, b.caret(e.$preview, e.last), e.setScroll()) }, shift: function (e) { e.last.keyset[0] = e.shiftActive = !e.shiftActive, e.showSet() }, sign: function (e) { var t, a, n; (e.decimal ? /^[+-]?\d*\.?\d*$/ : /^[+-]?\d*,?\d*$/).test(e.getValue()) && (t = b.caret(e.$preview), a = e.getValue(), n = e.isContentEditable ? b.getEditableLength(e.el) : a.length, e.setValue(-1 * a), a = n - a.length, e.last.start = t.start + a, e.last.end = t.end + a, b.caret(e.$preview, e.last), e.setScroll()) }, space: function (e) { e.insertText(" ") }, tab: function (e) { var t = e.options; if (!e.isTextArea) { if (t.tabNavigation) return e.switchInput(!e.shiftActive, !0); if (e.isInput) return !1 } e.insertText("\t") }, toggle: function (e) { e.enabled = !e.enabled, e.toggle() }, NBSP: " ", ZWSP: "​", ZWNJ: "‌", ZWJ: "‍", LRM: "‎", RLM: "‏" }, b.builtLayouts = {}, b.layouts = { alpha: { normal: ["` 1 2 3 4 5 6 7 8 9 0 - = {bksp}", "{tab} a b c d e f g h i j [ ] \\", "k l m n o p q r s ; ' {enter}", "{shift} t u v w x y z , . / {shift}", "{accept} {space} {cancel}"], shift: ["~ ! @ # $ % ^ & * ( ) _ + {bksp}", "{tab} A B C D E F G H I J { } |", 'K L M N O P Q R S : " {enter}', "{shift} T U V W X Y Z < > ? {shift}", "{accept} {space} {cancel}"] }, qwerty: { normal: ["` 1 2 3 4 5 6 7 8 9 0 - = {bksp}", "{tab} q w e r t y u i o p [ ] \\", "a s d f g h j k l ; ' {enter}", "{shift} z x c v b n m , . / {shift}", "{accept} {space} {cancel}"], shift: ["~ ! @ # $ % ^ & * ( ) _ + {bksp}", "{tab} Q W E R T Y U I O P { } |", 'A S D F G H J K L : " {enter}', "{shift} Z X C V B N M < > ? {shift}", "{accept} {space} {cancel}"] }, international: { normal: ["` 1 2 3 4 5 6 7 8 9 0 - = {bksp}", "{tab} q w e r t y u i o p [ ] \\", "a s d f g h j k l ; ' {enter}", "{shift} z x c v b n m , . / {shift}", "{accept} {alt} {space} {alt} {cancel}"], shift: ["~ ! @ # $ % ^ & * ( ) _ + {bksp}", "{tab} Q W E R T Y U I O P { } |", 'A S D F G H J K L : " {enter}', "{shift} Z X C V B N M < > ? {shift}", "{accept} {alt} {space} {alt} {cancel}"], alt: ["~ ¡ ² ³ ¤ € ¼ ½ ¾ ‘ ’ ¥ × {bksp}", "{tab} ä å é ® þ ü ú í ó ö « » ¬", "á ß ð f g h j k ø ¶ ´ {enter}", "{shift} æ x © v b ñ µ ç > ¿ {shift}", "{accept} {alt} {space} {alt} {cancel}"], "alt-shift": ["~ ¹ ² ³ £ € ¼ ½ ¾ ‘ ’ ¥ ÷ {bksp}", "{tab} Ä Å É ® Þ Ü Ú Í Ó Ö « » ¦", "Ä § Ð F G H J K Ø ° ¨ {enter}", "{shift} Æ X ¢ V B Ñ µ Ç . ¿ {shift}", "{accept} {alt} {space} {alt} {cancel}"] }, colemak: { normal: ["` 1 2 3 4 5 6 7 8 9 0 - = {bksp}", "{tab} q w f p g j l u y ; [ ] \\", "{bksp} a r s t d h n e i o ' {enter}", "{shift} z x c v b k m , . / {shift}", "{accept} {space} {cancel}"], shift: ["~ ! @ # $ % ^ & * ( ) _ + {bksp}", "{tab} Q W F P G J L U Y : { } |", '{bksp} A R S T D H N E I O " {enter}', "{shift} Z X C V B K M < > ? {shift}", "{accept} {space} {cancel}"] }, dvorak: { normal: ["` 1 2 3 4 5 6 7 8 9 0 [ ] {bksp}", "{tab} ' , . p y f g c r l / = \\", "a o e u i d h t n s - {enter}", "{shift} ; q j k x b m w v z {shift}", "{accept} {space} {cancel}"], shift: ["~ ! @ # $ % ^ & * ( ) { } {bksp}", '{tab} " < > P Y F G C R L ? + |', "A O E U I D H T N S _ {enter}", "{shift} : Q J K X B M W V Z {shift}", "{accept} {space} {cancel}"] }, num: { normal: ["= ( ) {b}", "{clear} / * -", "7 8 9 +", "4 5 6 {sign}", "1 2 3 %", "0 {dec} {a} {c}"] } }, b.language = { en: { display: { a: "✔:Accept (Shift+Enter)", accept: "Accept:Accept (Shift+Enter)", alt: "Alt:⌥ AltGr", b: "⌫:Backspace", bksp: "Bksp:Backspace", c: "✖:Cancel (Esc)", cancel: "Cancel:Cancel (Esc)", clear: "C:Clear", combo: "ö:Toggle Combo Keys", dec: ".:Decimal", e: "⏎:Enter", empty: " ", enter: "Enter:Enter ⏎", left: "←", lock: "Lock:⇪ Caps Lock", next: "Next ⇨", prev: "⇦ Prev", right: "→", s: "⇧:Shift", shift: "Shift:Shift", sign: "±:Change Sign", space: " :Space", t: "⇥:Tab", tab: "⇥ Tab:Tab", toggle: " ", valid: "valid", invalid: "invalid", active: "active", disabled: "disabled" }, wheelMessage: "Use mousewheel to see other keys", comboRegex: /([`\'~\^\"ao])([a-z])/gim, combos: { "`": { a: "à", A: "À", e: "è", E: "È", i: "ì", I: "Ì", o: "ò", O: "Ò", u: "ù", U: "Ù", y: "ỳ", Y: "Ỳ" }, "'": { a: "á", A: "Á", e: "é", E: "É", i: "í", I: "Í", o: "ó", O: "Ó", u: "ú", U: "Ú", y: "ý", Y: "Ý" }, '"': { a: "ä", A: "Ä", e: "ë", E: "Ë", i: "ï", I: "Ï", o: "ö", O: "Ö", u: "ü", U: "Ü", y: "ÿ", Y: "Ÿ" }, "^": { a: "â", A: "Â", e: "ê", E: "Ê", i: "î", I: "Î", o: "ô", O: "Ô", u: "û", U: "Û", y: "ŷ", Y: "Ŷ" }, "~": { a: "ã", A: "Ã", e: "ẽ", E: "Ẽ", i: "ĩ", I: "Ĩ", o: "õ", O: "Õ", u: "ũ", U: "Ũ", y: "ỹ", Y: "Ỹ", n: "ñ", N: "Ñ" } } } }, b.defaultOptions = { language: null, rtl: !1, layout: "qwerty", customLayout: null, position: { of: null, my: "center top", at: "center top", at2: "center bottom" }, reposition: !0, usePreview: !0, alwaysOpen: !1, initialFocus: !0, noFocus: !1, stayOpen: !1, userClosed: !1, ignoreEsc: !1, closeByClickEvent: !1, css: { input: "ui-widget-content ui-corner-all", container: "ui-widget-content ui-widget ui-corner-all ui-helper-clearfix", popup: "", buttonDefault: "ui-state-default ui-corner-all", buttonHover: "ui-state-hover", buttonAction: "ui-state-active", buttonActive: "ui-state-active", buttonDisabled: "ui-state-disabled", buttonEmpty: "ui-keyboard-empty" }, autoAccept: !1, autoAcceptOnEsc: !1, lockInput: !1, restrictInput: !1, restrictInclude: "", acceptValid: !1, autoAcceptOnValid: !1, checkValidOnInit: !0, cancelClose: !0, tabNavigation: !1, enterNavigation: !1, enterMod: "altKey", stopAtEnd: !0, appendLocally: !1, appendTo: "body", wrapBRs: !0, stickyShift: !0, preventPaste: !1, caretToEnd: !1, scrollAdjustment: 10, maxLength: !1, maxInsert: !0, repeatDelay: 500, repeatRate: 20, resetDefault: !0, openOn: "focus", activeOnReadonly: !1, keyBinding: "mousedown touchstart", useWheel: !0, useCombos: !0, validate: function () { return !0 } }, b.supportedInputTypes = ["text", "search", "url", "tel", "password"], b.comboRegex = /([`\'~\^\"ao])([a-z])/gim, b.currentKeyboard = "", y('\x3c!--[if lte IE 8]><script>jQuery("body").addClass("oldie");<\/script><![endif]--\x3e\x3c!--[if IE]><script>jQuery("body").addClass("ie");<\/script><![endif]--\x3e').appendTo("body").remove(), b.msie = y("body").hasClass("oldie"), b.allie = y("body").hasClass("ie"), b.watermark = void 0 !== document.createElement("input").placeholder, b.checkCaretSupport = function () { var e; return "boolean" != typeof b.checkCaret && (e = y('<div style="height:0px;width:0px;overflow:hidden;position:fixed;top:0;left:-100px;"><input type="text" value="testing"/></div>').prependTo("body"), b.caret(e.find("input"), 3, 3), b.checkCaret = 3 !== b.caret(e.find("input").hide().show()).start, e.remove()), b.checkCaret }, b.caret = function (e, t, a) { if (!e || !e.length || e.is(":hidden") || "hidden" === e.css("visibility")) return {}; var n, i, s, o = e.data("keyboard"), r = o && o.options.noFocus, o = /(textarea|input)/i.test(e[0].nodeName); return r || e.focus(), void 0 !== t ? ("object" == typeof t && "start" in t && "end" in t ? (n = t.start, i = t.end) : void 0 === a && (a = t), "number" == typeof t && "number" == typeof a ? (n = t, i = a) : "start" === t ? n = i = 0 : "string" == typeof t && (n = i = "end"), o ? e.caret(n, i, r) : b.setEditableCaret(e, n, i)) : (r = o ? e.caret() : b.getEditableCaret(e[0]), n = r.start, i = r.end, s = o && e[0].value || e.text() || "", { start: n, end: i, text: s.substring(n, i), replaceStr: function (e) { return s.substring(0, n) + e + s.substring(i, s.length) } }) }, b.isTextNode = function (e) { return e && 3 === e.nodeType }, b.isBlock = function (e, t) { var a = e.ownerDocument.defaultView; return t && 1 === t.nodeType && t !== e && "block" === a.getComputedStyle(t).display ? 1 : 0 }, b.wrapBRs = function (n) { var e = y(n).find("br:not(." + b.css.divWrapperCE + ")"); e.length && y.each(e, function (e, t) { var a = t.parentNode.childNodes.length; 1 === a && (1 !== a || b.isBlock(n, t.parentNode)) || y(t).addClass(b.css.divWrapperCE).wrap("<div>") }) }, b.getEditableCaret = function (l) { if (!(l = y(l)[0]).isContentEditable) return {}; var e, c = (y(l).data("keyboard") || {}).options, t = l.ownerDocument.getSelection().getRangeAt(0), a = i(t.startContainer, t.startOffset), n = a.position; function i(e, t) { var a, n = "", i = !1, s = 0, o = y.makeArray(l.childNodes); function r(e) { e && (s += e, n += c && c.replaceCR || "\n") } for (; !i && o.length;) { if ((a = o.shift()) === e && (i = !0), r(b.isBlock(l, a.previousSibling)), b.isTextNode(a)) { if (s += i ? t : a.length, n += a.textContent, i) return { position: s, text: n } } else !i && a.childNodes && (o = y.makeArray(a.childNodes).concat(o)); r(b.isTextNode(a.previousSibling) && b.isBlock(l, a)) } return { position: s, text: n } } return !1 !== c.wrapBRs && b.wrapBRs(l), a = t.endContainer === t.startContainer && t.endOffset === t.startOffset ? (e = n, "") : (e = (a = i(t.endContainer, t.endOffset)).position, a.text.substring(n, e)), { start: n, end: e, text: a } }, b.getEditableLength = function (e) { e = b.setEditableCaret(e, "getMax"); return "number" == typeof e ? e : null }, b.setEditableCaret = function (u, e, t) { if (!(u = y(u)[0]).isContentEditable) return {}; var a = u.ownerDocument, n = a.createRange(), i = a.getSelection(), p = (y(u).data("keyboard") || {}).options, s = e, o = t, r = "", a = l("getMax" === e ? "end" : e); function l(a) { "end" === a ? a = u.innerHTML.length : a < 0 && (a = 0); var e, t, n = "", i = !1, s = 0, o = 0, r = 0, l = y.makeArray(u.childNodes); function c(e) { return n += e ? p && p.replaceCR || "\n" : "", 0 < e } function d(e) { var t = s + e; return o = r, r += e, 0 <= a - t ? a - (s = t) <= 0 : a - t <= 0 } for (; !i && l.length;)if (e = l.shift(), c(t = b.isBlock(u, e.previousSibling)) && d(t) && (i = !0), c(t = b.isTextNode(e.previousSibling) && b.isBlock(u, e)) && d(t) && (i = !0), b.isTextNode(e)) { if (n += e.textContent, d(e.length)) return { node: e, offset: t = a - s == 0 && 1 <= s - o ? e.length : a - s, position: a, text: n } } else !i && e.childNodes && (l = y.makeArray(e.childNodes).concat(l)); return l.length ? { node: e, offset: a - s, position: a, text: n } : { node: e, offset: e && e.length || 0, position: r, text: n } } if (a.node) { if (s = a.position, "getMax" === e) return s; n.setStart(a.node, a.offset), void 0 !== t && t !== e && (a = l(t)), a.node && (o = a.position, n.setEnd(a.node, a.offset), r = s === o ? "" : a.text.substring(s, o)), i.removeAllRanges(), i.addRange(n) } return { start: s, end: o, text: r } }, b.replaceContent = function (e, t) { e = y(e)[0]; for (var a, n, i, s = typeof t, o = b.getEditableCaret(e).start, r = 0, l = [e]; a = l.pop();)if (b.isTextNode(a)) "function" == s ? r <= o && o <= r + a.length && (a.textContent = t(a.textContent)) : "string" == s && (i = t.substring(r, r + a.length)) !== a.textContent && (a.textContent = i), r += a.length; else if (a && a.childNodes) for (n = a.childNodes.length; n--;)l.push(a.childNodes[n]); n = b.getEditableCaret(e), b.setEditableCaret(e, n.start, n.start) }, y.fn.keyboard = function (e) { return this.each(function () { y(this).data("keyboard") || new y.keyboard(this, e) }) }, y.fn.getkeyboard = function () { return this.data("keyboard") }, y.fn.caret = function (t, a, e) { if (void 0 === this[0] || this.is(":hidden") || "hidden" === this.css("visibility") || !/(INPUT|TEXTAREA)/i.test(this[0].nodeName)) return this; var n, i, s, o = this, r = o[0], l = r.ownerDocument.selection, c = r.scrollTop, d = !1, u = !0; try { d = "selectionStart" in r } catch (e) { u = !1 } return u && void 0 !== t ? (/(email|number)/i.test(r.type) || (d ? (r.selectionStart = t, r.selectionEnd = a) : ((u = r.createTextRange()).collapse(!0), u.moveStart("character", t), u.moveEnd("character", a - t), u.select())), e || !o.is(":visible") && "hidden" === o.css("visibility") || r.focus(), r.scrollTop = c, this) : (/(email|number)/i.test(r.type) ? t = a = o.val().length : d ? (t = r.selectionStart, a = r.selectionEnd) : l ? a = "TEXTAREA" === r.nodeName.toUpperCase() ? (s = o.val(), (c = (n = l.createRange()).duplicate()).moveToElementText(r), c.setEndPoint("EndToEnd", n), (t = c.text.replace(/\r/g, "\n").length) + n.text.replace(/\r/g, "\n").length) : (s = o.val().replace(/\r/g, "\n"), (n = l.createRange().duplicate()).moveEnd("character", s.length), t = "" === n.text ? s.length : s.lastIndexOf(n.text), (n = l.createRange().duplicate()).moveStart("character", -s.length), n.text.length) : t = a = (r.value || "").length, i = r.value || "", { start: t, end: a, text: i.substring(t, a), replace: function (e) { return i.substring(0, t) + e + i.substring(a, i.length) } }) }, b });